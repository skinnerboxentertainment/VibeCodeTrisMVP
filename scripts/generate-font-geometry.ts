
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PIXI_RENDERER_PATH = path.join(__dirname, '../src/renderer/pixiRenderer.ts');
const OUTPUT_FILE_PATH = path.join(__dirname, '../src/renderer/pixel-font-geometry.ts');

interface PixelFontChar {
    nodes: [number, number][];
    edges: [number, number, number, number][];
}

interface PixelFontGeometry {
    [key: string]: PixelFontChar;
}

// Helper to check if a pixel is "on" (value 1)
function isPixelOn(x: number, y: number, charMatrix: number[][]): boolean {
    if (y < 0 || y >= charMatrix.length || x < 0 || x >= charMatrix[y].length) {
        return false; // Out of bounds is considered "off"
    }
    return charMatrix[y][x] === 1;
}

// Helper to get external edges for a given "on" pixel
function getEdgesForPixel(px: number, py: number, charMatrix: number[][]): [number, number, number, number][] {
    const edges: [number, number, number, number][] = [];
    const height = charMatrix.length;
    const width = charMatrix[0].length; // Assuming all rows have the same width

    // Top edge
    if (!isPixelOn(px, py - 1, charMatrix)) {
        edges.push([px, py, px + 1, py]);
    }
    // Bottom edge
    if (!isPixelOn(px, py + 1, charMatrix)) {
        edges.push([px, py + 1, px + 1, py + 1]);
    }
    // Left edge
    if (!isPixelOn(px - 1, py, charMatrix)) {
        edges.push([px, py, px, py + 1]);
    }
    // Right edge
    if (!isPixelOn(px + 1, py, charMatrix)) {
        edges.push([px + 1, py, px + 1, py + 1]);
    }
    return edges;
}

// Helper to extract unique nodes from a list of edges
function getNodesFromEdges(edges: [number, number, number, number][]): [number, number][] {
    const nodeSet = new Set<string>();
    for (const [x1, y1, x2, y2] of edges) {
        nodeSet.add(`${x1},${y1}`);
        nodeSet.add(`${x2},${y2}`);
    }
    return Array.from(nodeSet).map(s => {
        const [x, y] = s.split(',').map(Number);
        return [x, y];
    });
}

async function generateFontGeometry() {
    console.log('Reading pixiRenderer.ts...');
    const pixiRendererContent = fs.readFileSync(PIXI_RENDERER_PATH, 'utf-8');

    // Regex to extract the PIXEL_FONT object
    const pixelFontRegex = /const PIXEL_FONT: { \[key: string\]: number\[\]\[\] } = (\{[\s\S]*?\});/m;
    const match = pixelFontRegex.exec(pixiRendererContent);

    if (!match || !match[1]) {
        console.error('Could not find PIXEL_FONT in pixiRenderer.ts');
        process.exit(1);
    }

    // Safely evaluate the extracted string as a JavaScript object
    // This is generally unsafe with arbitrary code, but here we control the source.
    const pixelFontString = match[1]; // The regex now captures the full object
    let PIXEL_FONT: { [key: string]: number[][] };
    try {
        // Use a function to create a scope and evaluate the string
        PIXEL_FONT = new Function(`return ${pixelFontString}`)();
    } catch (e) {
        console.error('Error parsing PIXEL_FONT object:', e);
        process.exit(1);
    }

    const PIXEL_FONT_GEOMETRY: PixelFontGeometry = {};

    for (const char in PIXEL_FONT) {
        const charMatrix = PIXEL_FONT[char];
        const allEdgesForChar: [number, number, number, number][] = [];

        for (let y = 0; y < charMatrix.length; y++) {
            for (let x = 0; x < charMatrix[y].length; x++) {
                if (isPixelOn(x, y, charMatrix)) {
                    allEdgesForChar.push(...getEdgesForPixel(x, y, charMatrix));
                }
            }
        }

        // Filter out duplicate edges (e.g., if two adjacent pixels share an internal edge)
        const uniqueEdgesMap = new Map<string, [number, number, number, number]>();
        for (const edge of allEdgesForChar) {
            // Normalize edge representation to handle [x1,y1,x2,y2] and [x2,y2,x1,y1] as the same
            const key = [edge[0], edge[1], edge[2], edge[3]].sort().join(',');
            uniqueEdgesMap.set(key, edge);
        }
        const uniqueEdges = Array.from(uniqueEdgesMap.values());

        const nodes = getNodesFromEdges(uniqueEdges);

        PIXEL_FONT_GEOMETRY[char] = {
            nodes: nodes,
            edges: uniqueEdges,
        };
    }

    const outputContent = `// src/renderer/pixel-font-geometry.ts
// This file is auto-generated by scripts/generate-font-geometry.ts
// Do not modify directly.

export interface PixelFontCharGeometry {
    nodes: [number, number][];
    edges: [number, number, number, number][];
}

export const PIXEL_FONT_GEOMETRY: { [key: string]: PixelFontCharGeometry } = ${JSON.stringify(PIXEL_FONT_GEOMETRY, null, 2)};
`;

    fs.writeFileSync(OUTPUT_FILE_PATH, outputContent, 'utf-8');
    console.log(`Generated font geometry to ${OUTPUT_FILE_PATH}`);
}

generateFontGeometry().catch(console.error);
